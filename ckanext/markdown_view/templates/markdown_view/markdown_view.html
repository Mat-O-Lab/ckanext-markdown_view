<link rel="stylesheet" href="/markdown_view.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.15/dist/katex.min.css"
    integrity="sha384-Htz9HMhiwV8GuQ28Xr9pEs1B4qJiYu/nYLLwlDklR53QibDfmQzi7rYxXhMH/5/u" crossorigin="anonymous">
<div id="markdown_content">
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.5/purify.min.js"
    integrity="sha512-JatFEe90fJU2nrgf27fUz2hWRvdYrSlTEV8esFuqCtfiqWN8phkS1fUl/xCfYyrLDQcNf3YyS0V9hG7U4RHNmQ=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.2/marked.min.js"
    integrity="sha512-xeUh+KxNyTufZOje++oQHstlMQ8/rpyzPuM+gjMFYK3z5ILJGE7l2NvYL+XfliKURMpBIKKp1XoPN/qswlSMFA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="
https://cdn.jsdelivr.net/npm/marked-extended-tables@1.0.8/lib/index.umd.min.js
"></script>
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.15/dist/katex.min.js"
    integrity="sha384-bxmi2jLGCvnsEqMuYLKE/KsVCxV3PqmKeK6Y6+lmNXBry6+luFkEOsmp5vD9I/7+"
    crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.15/dist/contrib/auto-render.min.js"
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: true },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            // • rendering keys, e.g.:
            throwOnError: false
        });
    });
</script>

<script>
    function cleanMathExpression(expression) {
        // Additional clean-up for zero-width characters or other formatting issues
        // Now remove the curly braces around \bigg{...} and keep the content
        expression = expression.replace(/\\bigg\{([^\}]*?)\}/g, '\\bigg$1 '); // \bigg{whatever} -> \biggwhatever
        // Replace \left{ and \right} with \left( and \right)
        // Replace \left{ with \left( 
        expression = expression.replace(/\\left\\{/g, '\\left(');

        // Replace \right} with \right)
        expression = expression.replace(/\\right\\}/g, '\\right)');
        return expression;
    }
    marked.use("marked-extended-tables", "gfm");
    const renderer = new marked.Renderer();
    renderer.image = function (href, title, text) {
        return `<img class="img-fluid" src="${href}" alt="${text}" title="${title}" />`; // for local references
    };
    renderer.paragraph = function (text) {
        return `<p class="text-break"/>${text}</p>`;
    };
    marked.use({ renderer });
    // Override function
    // const tokenizer = {
    //     codespan(src) {
    //         const match = src.match(/^\$+([^\$\n]+?)\$+/);
    //         if (match) {
    //             return {
    //                 type: 'codespan',
    //                 raw: match[0],
    //                 text: match[1].trim()
    //             };
    //         }

    //         // return false to use original codespan tokenizer
    //         return false;
    //     }
    // };
    // marked.use({ tokenizer });
    // fetch("{{ resource_view.get('page_url') or resource.get('url') }}")      // The path to the raw Markdown file
    //     .then(response => response.blob())  // Unwrap to a blob...
    //     .then(blob => blob.text())          // ...then to raw text...
    //     .then(markdown => {                 // ...then pass the raw text into marked.parse
    //         document.getElementById("markdown_content").innerHTML = DOMPurify.sanitize(marked.parse(markdown.replace(/^[\u200B\u200C\u200D\u200E\u200F\uFEFF]/, "")));
    //     });
    fetch("{{ resource_view.get('page_url') or resource.get('url') }}")  // Path to raw Markdown file
        .then(response => response.blob())  // Unwrap to a blob...
        .then(blob => blob.text())  // Convert to text
        .then(markdown => {
            // Sanitize and clean up the markdown text before parsing
            // markdown = markdown.replace(/[^\x20-\x7E\x0A\x0D]/g, ''); // Remove non-printable characters

            // Clean the markdown for math expressions
            markdown = markdown.replace(/\$\$[\s\S]*?\$\$/g, match => cleanMathExpression(match)); // Clean block math
            markdown = markdown.replace(/\$[\s\S]*?\$/g, match => cleanMathExpression(match)); // Clean inline math

            // Parsing the Markdown text into HTML
            let parsedHTML = marked.parse(markdown.replace(/^[\u200B\u200C\u200D\u200E\u200F\uFEFF]/, ""));

            // Sanitize the generated HTML content
            parsedHTML = DOMPurify.sanitize(parsedHTML);

            // Inject sanitized HTML into the page
            const contentDiv = document.getElementById("markdown_content");
            contentDiv.innerHTML = parsedHTML;
        })
        .catch(error => console.error("Failed to load Markdown content:", error));
</script>